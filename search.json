[
  {
    "objectID": "example_3.html",
    "href": "example_3.html",
    "title": "Example #3",
    "section": "",
    "text": "Some examples of non-proprietary analysis.\nWork in progress"
  },
  {
    "objectID": "example_1.html",
    "href": "example_1.html",
    "title": "Example #1",
    "section": "",
    "text": "This seems like an excellent starting point pbmc3k\n\nPeripheral Blood Mononuclear Cells (PBMC)\n10X Genomics\n2,700 single cells\nsequenced on Illumina NextSeq 500"
  },
  {
    "objectID": "example_1.html#overview",
    "href": "example_1.html#overview",
    "title": "Example #1",
    "section": "",
    "text": "This seems like an excellent starting point pbmc3k\n\nPeripheral Blood Mononuclear Cells (PBMC)\n10X Genomics\n2,700 single cells\nsequenced on Illumina NextSeq 500"
  },
  {
    "objectID": "example_1.html#background",
    "href": "example_1.html#background",
    "title": "Example #1",
    "section": "Background",
    "text": "Background\n\nHighly Parallel Genome-wide Expression Profiling of Individual Cells Using Nanoliter Droplets\n\nCell, 2015\nDrop-Seq barcoding schematic\n\nprimer bead, sequence domains\n\n|— PCR —| — cell barcode —| — UMI — | — polyT27 — |\nUMI: Unique Molecular IDs region\n\n\nPaired end reads"
  },
  {
    "objectID": "example_1.html#import-data",
    "href": "example_1.html#import-data",
    "title": "Example #1",
    "section": "Import Data",
    "text": "Import Data\n\nLibraries\n\nlibrary(dplyr)\n\n\nAttaching package: 'dplyr'\n\n\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n\n\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n\nlibrary(Seurat)\n\nAttaching SeuratObject\n\n\n'SeuratObject' was built under R 4.3.0 but the current version is\n4.3.1; it is recomended that you reinstall 'SeuratObject' as the ABI\nfor R may have changed\n\n\nSeurat v4 was just loaded with SeuratObject v5; disabling v5 assays and\nvalidation routines, and ensuring assays work in strict v3/v4\ncompatibility mode\n\nlibrary(patchwork)\n\n\n# Data downloaded into git repo \n#   29 MB for barcodes, genes and matrix files \n# NB: these data are already filtered for barcodes within data\n# unfiltered would include all possible barcodes \n# (all synthesized barcodes or all theoretical possibilites given\n# a certain n of synthesis cycles? would need to delve into bead synthesis here)\ndata_dir &lt;- \"./filtered_gene_bc_matrices/hg19/\"\nlist.files(path = data_dir)\n\n[1] \"barcodes.tsv\" \"genes.tsv\"    \"matrix.mtx\"  \n\n\n\n\nIndepenedent look at data files\n\n# indepenedant look at files to be grounded..\n# TSVs\ngenes_tsv &lt;- read.csv(paste0(data_dir, \"genes.tsv\"), sep = \"\\t\", header = FALSE)\npaste0(\"n genes: \",nrow(genes_tsv), \". Some rows...\")\n\n[1] \"n genes: 32738. Some rows...\"\n\nhead(genes_tsv)\n\n               V1           V2\n1 ENSG00000243485   MIR1302-10\n2 ENSG00000237613      FAM138A\n3 ENSG00000186092        OR4F5\n4 ENSG00000238009 RP11-34P13.7\n5 ENSG00000239945 RP11-34P13.8\n6 ENSG00000237683   AL627309.1\n\nrm(genes_tsv)\n\nbarcode_tsv &lt;- read.csv(paste0(data_dir, \"barcodes.tsv\"), sep = \"\\t\", header = FALSE)\npaste0(\"n cell barcodes: \", nrow(barcode_tsv), \". Some rows...\")\n\n[1] \"n cell barcodes: 2700. Some rows...\"\n\nhead(barcode_tsv)\n\n                V1\n1 AAACATACAACCAC-1\n2 AAACATTGAGCTAC-1\n3 AAACATTGATCAGC-1\n4 AAACCGTGCTTCCG-1\n5 AAACCGTGTATGCG-1\n6 AAACGCACTGGTAC-1\n\nrm(barcode_tsv)\n\n# Sample of matrix \n# line 3 is n genes, n cells (barcodes), n lines of data  \n# line &gt;3 gene\n# gene_id barcode_id, umi_count\nreadLines(paste0(data_dir, \"matrix.mtx\"),10)\n\n [1] \"%%MatrixMarket matrix coordinate real general\"\n [2] \"%\"                                            \n [3] \"32738 2700 2286884\"                           \n [4] \"32709 1 4\"                                    \n [5] \"32707 1 1\"                                    \n [6] \"32706 1 10\"                                   \n [7] \"32704 1 1\"                                    \n [8] \"32703 1 5\"                                    \n [9] \"32702 1 6\"                                    \n[10] \"32700 1 10\"                                   \n\n# we can see sparsity from these numbers\n(1 - (2286884 / (32738 * 2700))) * 100\n\n[1] 97.41281\n\n# Sparse Matrix is a \"dgTMatrix\"\nsparse_m &lt;- Matrix::readMM(paste0(data_dir, \"matrix.mtx\"))\n#class(sparse_m)\nn_row_genes &lt;- nrow(sparse_m)\nn_col_cells &lt;- ncol(sparse_m)\nsparsity &lt;- round( sum(sparse_m == 0) / length(sparse_m)  * 100,2)\ndgTMatrix_summary &lt;- paste0(\"n_row_genes: \", n_row_genes, \n                            \", n_col_cells: \", n_col_cells, \n                            \", sparsity: \", sparsity, \" %\")\ndgTMatrix_summary\n\n[1] \"n_row_genes: 32738, n_col_cells: 2700, sparsity: 97.41 %\"\n\nrm(sparse_m)\n\n\n\nStandard import\n\n# creates dgCMatrix of all 3 files content\npbmc.data &lt;- Read10X(data.dir = data_dir)\n# class(pbmc.data)\n\n# Seurat object with the raw (non-normalized data).\n\n# Keep genes expressed in at least min.cells\n# Include cells where at least min.features are detected\npbmc &lt;- CreateSeuratObject(counts = pbmc.data, \n                           project = \"pbmc3k\", \n                           min.cells = 3, \n                           min.features = 200)\n\nWarning: Feature names cannot have underscores ('_'), replacing with dashes\n('-')\n\nWarning: Feature names cannot have underscores ('_'), replacing with dashes\n('-')\n\n# Seurat object has reduced number of features (genes)\n# and possiblly samples (cells) with harsher paremeters\n# min.cells = 50, min.features = 400\npbmc\n\nAn object of class Seurat \n13714 features across 2700 samples within 1 assay \nActive assay: RNA (13714 features, 0 variable features)\n 2 layers present: counts, data"
  },
  {
    "objectID": "example_1.html#pre-processing",
    "href": "example_1.html#pre-processing",
    "title": "Example #1",
    "section": "Pre-processing",
    "text": "Pre-processing\nBlockquote:\n\nSeurat allows you to easily explore QC metrics and filter cells based on any user-defined criteria. A few QC metrics commonly used by the community include\n\nThe number of unique genes detected in each cell.\n\nLow-quality cells or empty droplets will often have very few genes\nCell doublets or multiplets may exhibit an aberrantly high gene count\n\nSimilarly, the total number of molecules detected within a cell (correlates strongly with unique genes)\nThe percentage of reads that map to the mitochondrial genome\n\nLow-quality / dying cells often exhibit extensive mitochondrial contamination\nWe calculate mitochondrial QC metrics with the PercentageFeatureSet() function, which calculates the percentage of counts originating from a set of features\nWe use the set of all genes starting with MT- as a set of mitochondrial genes\n\n\n\n\nMeta data stash, calculations and basis for filtering\n\n# Stashing meta data\nhead(pbmc@meta.data, 5)\n\n                 orig.ident nCount_RNA nFeature_RNA\nAAACATACAACCAC-1     pbmc3k       2419          779\nAAACATTGAGCTAC-1     pbmc3k       4903         1352\nAAACATTGATCAGC-1     pbmc3k       3147         1129\nAAACCGTGCTTCCG-1     pbmc3k       2639          960\nAAACCGTGTATGCG-1     pbmc3k        980          521\n\n# The [[ operator can add columns to object metadata. \n# In this case the % mitochondrial DNA based on syntax of gene naming\n# \npbmc[[\"percent.mt\"]] &lt;- PercentageFeatureSet(pbmc, pattern = \"^MT-\")\n\nhead(pbmc@meta.data, 5)\n\n                 orig.ident nCount_RNA nFeature_RNA percent.mt\nAAACATACAACCAC-1     pbmc3k       2419          779  3.0177759\nAAACATTGAGCTAC-1     pbmc3k       4903         1352  3.7935958\nAAACATTGATCAGC-1     pbmc3k       3147         1129  0.8897363\nAAACCGTGCTTCCG-1     pbmc3k       2639          960  1.7430845\nAAACCGTGTATGCG-1     pbmc3k        980          521  1.2244898\n\n\nThe MT- genes from genes.csv from a bash shell grep. Sure there is a way to get the same from Seurat object.\n\n# bash grep\ngrep '\\tMT-' ./filtered_gene_bc_matrices/hg19/genes.tsv \n\nENSG00000198888 MT-ND1\nENSG00000198763 MT-ND2\nENSG00000198804 MT-CO1\nENSG00000198712 MT-CO2\nENSG00000228253 MT-ATP8\nENSG00000198899 MT-ATP6\nENSG00000198938 MT-CO3\nENSG00000198840 MT-ND3\nENSG00000212907 MT-ND4L\nENSG00000198886 MT-ND4\nENSG00000198786 MT-ND5\nENSG00000198695 MT-ND6\nENSG00000198727 MT-CYB\n\n\n\n# Visualize QC metrics as a violin plot\nVlnPlot(pbmc, features = c(\"nFeature_RNA\", \"nCount_RNA\", \"percent.mt\"),\n        ncol = 3)\n\n\n\n\n\n# FeatureScatter is typically used to visualize feature-feature relationships \n# but can be used for anything calculated by the object, \n# i.e. columns in object metadata, PC scores etc.\n\nplot1 &lt;- FeatureScatter(pbmc, feature1 = \"nCount_RNA\", feature2 = \"percent.mt\")\nplot2 &lt;- FeatureScatter(pbmc, feature1 = \"nCount_RNA\", feature2 = \"nFeature_RNA\")\nplot1 + plot2\n\n\n\n\n\n\nFiltering\nSome “exceptions” are dealt with at this stage\n\nA high ratio of mitochondrial DNA:nuclear DNA is typical of a dead or broken cell\nMultiple cells per drop is atypical but they can be picked up by high number of RNA counts\nEmpties are drops without intact cells but produce signal due to background RNA molecules from lyzed cells: they are filtered by having low gene (feature) count but that was already done in this case when the data was imported (see earlier)\nThere can be other issues e.g. barcode synthesis errors. Need to fix barcode/remove cell.\nThis filtering is at least kingdom specific - think of plant cells and chloroplast RNA, guard cells and endoreduplication….and rapidly dividing cultures of yeast and microbial cells that at the population level partly 2n\n\n\n# apply filters and overwrite the object!\npbmc &lt;- subset(pbmc, subset = nFeature_RNA &gt; 200 & \n                 nFeature_RNA &lt; 2500 & percent.mt &lt; 5)\n\n# what was the point of storing meta data?!\n# \n# It's OK, this meta-data is retained\n\nhead(pbmc@meta.data, 5)\n\n                 orig.ident nCount_RNA nFeature_RNA percent.mt\nAAACATACAACCAC-1     pbmc3k       2419          779  3.0177759\nAAACATTGAGCTAC-1     pbmc3k       4903         1352  3.7935958\nAAACATTGATCAGC-1     pbmc3k       3147         1129  0.8897363\nAAACCGTGCTTCCG-1     pbmc3k       2639          960  1.7430845\nAAACCGTGTATGCG-1     pbmc3k        980          521  1.2244898\n\n# And we can see clearly the effect of filtering\nplot1 &lt;- FeatureScatter(pbmc, feature1 = \"nCount_RNA\", feature2 = \"percent.mt\")\nplot2 &lt;- FeatureScatter(pbmc, feature1 = \"nCount_RNA\", feature2 = \"nFeature_RNA\")\nplot1 + plot2\n\n\n\n\nRemember nFeature_RNA is the number of detected genes and the nCount_RNA is the total counts per drop (after filtering that should now be per single cell though in the case the one outlier point makes me wonder….seems like ~2000 features is the upper range….).\nAnother thought in passing: presumably alternative splice forms are mapped to the same gene as standard practice. Would like to look for an example of where splice forms are treated as separate entities which should be in principle possible."
  },
  {
    "objectID": "example_1.html#normalization",
    "href": "example_1.html#normalization",
    "title": "Example #1",
    "section": "Normalization",
    "text": "Normalization\n\nAfter removing unwanted cells from the data-set, the next step is to normalize the data. By default, we employ a global-scaling normalization method \"LogNormalize\" that normalizes the feature expression measurements for each cell by the total expression, multiplies this by a scale factor (10,000 by default), and log-transforms the result. Normalized values are stored in pbmc[[\"RNA\"]]@data.\n\n\n# \npbmc &lt;- NormalizeData(pbmc, normalization.method = \"LogNormalize\", \n                      scale.factor = 10000)\n\n# Show a small sample of data\n# Again, it's a sparse matrix \n# class(pbmc[[\"RNA\"]]@data)\nstr(pbmc[[\"RNA\"]]@data)\n\nFormal class 'dgCMatrix' [package \"Matrix\"] with 6 slots\n  ..@ i       : int [1:2238732] 29 73 80 148 163 184 186 227 229 230 ...\n  ..@ p       : int [1:2639] 0 779 2131 3260 4220 4741 5522 6304 7094 7626 ...\n  ..@ Dim     : int [1:2] 13714 2638\n  ..@ Dimnames:List of 2\n  .. ..$ : chr [1:13714] \"AL627309.1\" \"AP006222.2\" \"RP11-206L10.2\" \"RP11-206L10.9\" ...\n  .. ..$ : chr [1:2638] \"AAACATACAACCAC-1\" \"AAACATTGAGCTAC-1\" \"AAACATTGATCAGC-1\" \"AAACCGTGCTTCCG-1\" ...\n  ..@ x       : num [1:2238732] 1.64 1.64 2.23 1.64 1.64 ...\n  ..@ factors : list()\n\n# 10 rows, 3 columns\npbmc[[\"RNA\"]]@data[10:20,1:3]\n\n11 x 3 sparse Matrix of class \"dgCMatrix\"\n             AAACATACAACCAC-1 AAACATTGAGCTAC-1 AAACATTGATCAGC-1\nHES4                        .         .                .       \nRP11-54O7.11                .         .                .       \nISG15                       .         .                1.429744\nAGRN                        .         .                .       \nC1orf159                    .         .                .       \nTNFRSF18                    .         1.625141         .       \nTNFRSF4                     .         .                .       \nSDF4                        .         .                1.429744\nB3GALT6                     .         .                .       \nFAM132A                     .         .                .       \nUBE2J2                      .         .                ."
  },
  {
    "objectID": "example_1.html#highly-variable-features",
    "href": "example_1.html#highly-variable-features",
    "title": "Example #1",
    "section": "Highly variable features",
    "text": "Highly variable features\n\nWe next calculate a subset of features that exhibit high cell-to-cell variation in the dataset (i.e, they are highly expressed in some cells, and lowly expressed in others). We and others have found that focusing on these genes in downstream analysis helps to highlight biological signal in single-cell datasets.\nOur procedure in Seurat is described in detail here, and improves on previous versions by directly modeling the mean-variance relationship inherent in single-cell data, and is implemented in the FindVariableFeatures() function. By default, we return 2,000 features per dataset. These will be used in downstream analysis, like PCA.\n\n\npbmc &lt;- FindVariableFeatures(pbmc, selection.method = \"vst\", nfeatures = 2000)\n\n# Identify the 10 most highly variable genes\ntop10 &lt;- head(VariableFeatures(pbmc), 10)\n\n# plot variable features with and without labels\nplot1 &lt;- VariableFeaturePlot(pbmc)\nplot2 &lt;- LabelPoints(plot = plot1, points = top10, repel = TRUE)\n\nWhen using repel, set xnudge and ynudge to 0 for optimal results\n\nplot1\n\nWarning: Transformation introduced infinite values in continuous x-axis\n\n\n\n\nplot2 \n\nWarning: Transformation introduced infinite values in continuous x-axis"
  },
  {
    "objectID": "example_1.html#data-scaling",
    "href": "example_1.html#data-scaling",
    "title": "Example #1",
    "section": "Data Scaling",
    "text": "Data Scaling\nNormally i do a mean 0, standard dev 1 … but the method used here is more sophisticated.\n\nNext, we apply a linear transformation ('scaling') that is a standard pre-processing step prior to dimensional reduction techniques like PCA. The ScaleData() function:\n\nShifts the expression of each gene, so that the mean expression across cells is 0\nScales the expression of each gene, so that the variance across cells is 1\n\nThis step gives equal weight in downstream analyses, so that highly-expressed genes do not dominate\n\nThe results of this are stored in pbmc[[\"RNA\"]]@scale.data\n\n\n\nall.genes &lt;- rownames(pbmc)\npbmc &lt;- ScaleData(pbmc, features = all.genes)\n\nCentering and scaling data matrix\n\n\nAnd there is a faster way…\n\nScaling is an essential step in the Seurat workflow, but only on genes that will be used as input to PCA. Therefore, the default in ScaleData() is only to perform scaling on the previously identified variable features (2,000 by default). To do this, omit the features argument in the previous function call, i.e.\npbmc &lt;- ScaleData(pbmc)\nYour PCA and clustering results will be unaffected. However, Seurat heatmaps (produced as shown below with DoHeatmap()) require genes in the heatmap to be scaled, to make sure highly-expressed genes don't dominate the heatmap. To make sure we don't leave any genes out of the heatmap later, we are scaling all genes in this tutorial.\n\nThis following section refers to the paper Normalization and variance stabilization of single-cell RNA-seq data using regularized negative binomial regression Christoph Hafemeister & Rahul Satija (2019). I have this in paper notes as the method to deal with cell cycle genes. Interesting would be circadian cycle - I came across experimental data before that hadn’t considered this aspect in the experimental design!!\n\nHow can I remove unwanted sources of variation, as in Seurat v2?\nIn Seurat v2 we also use the ScaleData() function to remove unwanted sources of variation from a single-cell dataset. For example, we could 'regress out' heterogeneity associated with (for example) cell cycle stage, or mitochondrial contamination. These features are still supported in ScaleData() in Seurat v3, i.e.:\npbmc &lt;- ScaleData(pbmc, vars.to.regress = \"percent.mt\")\nHowever, particularly for advanced users who would like to use this functionality, we strongly recommend the use of our new normalization workflow, SCTransform(). The method is described in our paper, with a separate vignette using Seurat v3 here. As with ScaleData(), the function SCTransform() also includes a vars.to.regress parameter."
  },
  {
    "objectID": "example_1.html#dimension-reduction",
    "href": "example_1.html#dimension-reduction",
    "title": "Example #1",
    "section": "Dimension reduction",
    "text": "Dimension reduction\nto be continued…"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "RNA Seq Analysis",
    "section": "",
    "text": "Having some experience of analyzing gene expression data with various tools from GeneSpring through edgeR and more recently having followed tutorials on Single-cell RNA-seq data analysis using Chipster (Seurat based workflows including SingleR, CellDex, CCA, RPCA [Chipster Tutorials, 2023]), my objective is to go deeper into Seurat to refine understanding using publicly available data-sets.\nSome examples of non-proprietary analysis. Work in progress"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About me"
  },
  {
    "objectID": "example_2.html",
    "href": "example_2.html",
    "title": "Example #2",
    "section": "",
    "text": "Some examples of non-proprietary analysis.\nWork in progress"
  }
]